webpackHotUpdate(0,{

/***/ 273:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("function validatePadding (padding) {\n  var arr = padding\n    .split(\" \")\n    .filter(function (item) { return item !== \"\"; })\n    .map(function (item) { return parseInt(item); });\n  if (arr.length < 1 || arr.length > 4) { return false; }\n  return arr.every(function (item) { return typeof item == \"number\" && item >= 0; });\n}\n\nfunction getPadding (padding) {\n  var arr = padding\n    .split(\" \")\n    .filter(function (item) { return item !== \"\"; })\n    .map(function (item) { return parseInt(item); });\n  switch (arr.length) {\n    case 4:\n      return { top: arr[0], right: arr[1], bottom: arr[2], left: arr[3] };\n      break;\n    case 3:\n      return { top: arr[0], right: arr[1], bottom: arr[2], left: arr[1] };\n      break;\n    case 2:\n      return { top: arr[0], right: arr[1], bottom: arr[0], left: arr[1] };\n      break;\n    default:\n      return { top: arr[0], right: arr[0], bottom: arr[0], left: arr[0] };\n      break;\n  }\n}\n\nvar TrendChartGrid = {\n  name: \"TrendChartGrid\",\n  props: {\n    boundary: {\n      required: true,\n      type: Object\n    },\n    verticalLines: {\n      default: false,\n      type: Boolean\n    },\n    verticalLinesNumber: {\n      default: 0,\n      type: Number\n    },\n    horizontalLines: {\n      default: false,\n      type: Boolean\n    },\n    horizontalLinesNumber: {\n      default: 0,\n      type: Number\n    }\n  },\n  methods: {\n    setVerticalLinesParams: function setVerticalLinesParams(n) {\n      var ref = this;\n      var boundary = ref.boundary;\n      var verticalLinesNumber = ref.verticalLinesNumber;\n      var step =\n        verticalLinesNumber > 1\n          ? (boundary.maxX - boundary.minX) / (verticalLinesNumber - 1)\n          : 0;\n      var x = boundary.minX + step * (n - 1);\n      var y1 = boundary.minY;\n      var y2 = boundary.maxY;\n      return {\n        x1: x,\n        x2: x,\n        y1: y1,\n        y2: y2,\n        stroke: \"rgba(0,0,0,0.1)\"\n      };\n    },\n    setHorizontalLinesParams: function setHorizontalLinesParams(n) {\n      var ref = this;\n      var boundary = ref.boundary;\n      var horizontalLinesNumber = ref.horizontalLinesNumber;\n      var step =\n        horizontalLinesNumber > 1\n          ? (boundary.maxY - boundary.minY) / (horizontalLinesNumber - 1)\n          : 0;\n      var y = boundary.maxY - step * (n - 1);\n      var x1 = boundary.minX;\n      var x2 = boundary.maxX;\n      return {\n        x1: x1,\n        x2: x2,\n        y1: y,\n        y2: y,\n        stroke: \"rgba(0,0,0,0.1)\"\n      };\n    }\n  },\n  render: function render(h) {\n    if (!this.verticalLines && !this.horizontalLines) { return; }\n\n    var children = [];\n\n    // Vertical Lines\n    if (this.verticalLines && this.verticalLinesNumber > 0) {\n      var lines = [];\n      for (var i = 1; i <= this.verticalLinesNumber; i++) {\n        lines.push(\n          h(\"line\", {\n            class: \"line\",\n            attrs: Object.assign({}, this.setVerticalLinesParams(i))\n          })\n        );\n      }\n      children.push(\n        h(\n          \"g\",\n          {\n            class: \"vertical\"\n          },\n          lines\n        )\n      );\n    }\n    // Horizontal Lines\n    if (this.horizontalLines && this.horizontalLinesNumber > 0) {\n      var lines$1 = [];\n      for (var i$1 = 1; i$1 <= this.horizontalLinesNumber; i$1++) {\n        lines$1.push(\n          h(\"line\", {\n            class: \"line\",\n            attrs: Object.assign({}, this.setHorizontalLinesParams(i$1))\n          })\n        );\n      }\n      children.push(\n        h(\n          \"g\",\n          {\n            class: \"horizontal\"\n          },\n          lines$1\n        )\n      );\n    }\n\n    // Render component\n    return h(\"g\", children);\n  }\n};\n\nvar TrendChartLabels = {\n  name: \"TrendChartLabels\",\n  props: {\n    boundary: {\n      required: true,\n      type: Object\n    },\n    minValue: {\n      type: Number\n    },\n    maxValue: {\n      type: Number\n    },\n    xLabels: {\n      type: Array\n    },\n    yLabels: {\n      type: Number\n    },\n    yLabelsTextFormatter: {\n      default: function (value) { return value; },\n      type: Function\n    }\n  },\n  data: function data() {\n    return {\n      xLabelHeight: null,\n      yLabelHeight: null\n    };\n  },\n  methods: {\n    setXLabelsParams: function setXLabelsParams(n) {\n      var ref = this;\n      var boundary = ref.boundary;\n      var xLabels = ref.xLabels;\n      var step = (boundary.maxX - boundary.minX) / (xLabels.length - 1);\n      var x = boundary.minX + step * n;\n      var y = boundary.maxY;\n      return { transform: (\"translate(\" + x + \", \" + y + \")\") };\n    },\n    setYLabelsParams: function setYLabelsParams(n) {\n      var ref = this;\n      var boundary = ref.boundary;\n      var yLabels = ref.yLabels;\n      var step = (boundary.maxY - boundary.minY) / (yLabels - 1);\n      var x = boundary.minX;\n      var y = boundary.maxY - step * n;\n      return { transform: (\"translate(\" + x + \", \" + y + \")\") };\n    }\n  },\n  mounted: function mounted() {\n    if (this.xLabels && this.xLabels.length) {\n      this.xLabelHeight = this.$refs.xLabels\n        .querySelector(\"text\")\n        .getBoundingClientRect().height;\n    }\n    if (this.yLabels && this.yLabels > 0) {\n      this.yLabelHeight = this.$refs.yLabels\n        .querySelector(\"text\")\n        .getBoundingClientRect().height;\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    if (\n      !(this.xLabels && this.xLabels.length) &&\n      !(this.yLabels && this.yLabels > 0)\n    )\n      { return; }\n\n    var children = [];\n\n    // x labels\n    if (this.xLabels && this.xLabels.length) {\n      children.push(\n        h(\n          \"g\",\n          {\n            class: \"x-labels\",\n            ref: \"xLabels\"\n          },\n          this.xLabels.map(function (label, i) {\n            return h(\n              \"g\",\n              {\n                class: \"label\",\n                attrs: Object.assign({}, this$1.setXLabelsParams(i))\n              },\n              [\n                h(\n                  \"text\",\n                  {\n                    attrs: {\n                      dy: this$1.xLabelHeight + 5,\n                      \"text-anchor\": \"middle\"\n                    }\n                  },\n                  label\n                ),\n                h(\"line\", { attrs: { stroke: \"rgba(0,0,0,0.1)\", y2: 5 } })\n              ]\n            );\n          })\n        )\n      );\n    }\n\n    // y labels\n    if (this.yLabels && this.yLabels > 0) {\n      var labels = [];\n      for (var i = 0; i < this.yLabels; i++) {\n        labels.push(\n          h(\n            \"g\",\n            {\n              class: \"label\",\n              attrs: Object.assign({}, this.setYLabelsParams(i))\n            },\n            [\n              h(\n                \"text\",\n                {\n                  attrs: {\n                    dx: -10,\n                    dy: this.yLabelHeight / 4,\n                    \"text-anchor\": \"end\"\n                  }\n                },\n                this.yLabelsTextFormatter(\n                  this.minValue +\n                    ((this.maxValue - this.minValue) / (this.yLabels - 1)) * i\n                )\n              ),\n              h(\"line\", { attrs: { stroke: \"rgba(0,0,0,0.1)\", x1: 0, x2: -5 } })\n            ]\n          )\n        );\n      }\n      children.push(\n        h(\n          \"g\",\n          {\n            class: \"y-labels\",\n            ref: \"yLabels\"\n          },\n          labels\n        )\n      );\n    }\n\n    // Render component\n    return h(\"g\", children);\n  }\n};\n\nfunction genPoints (arr, ref, max, min, maxAmount) {\n  var minX = ref.minX;\n  var minY = ref.minY;\n  var maxX = ref.maxX;\n  var maxY = ref.maxY;\n\n  arr = arr.map(function (item) { return (typeof item === \"number\" ? item : item.value); });\n  var minValue = min - 0.001;\n  var gridX = (maxX - minX) / (maxAmount - 1);\n  var gridY = (maxY - minY) / (max + 0.001 - minValue);\n\n  return arr.map(function (value, index) {\n    return {\n      x: index * gridX + minX,\n      y:\n        maxY -\n        (value - minValue) * gridY +\n        +(index === maxAmount - 1) * 0.00001 -\n        +(index === 0) * 0.00001\n    };\n  });\n}\n\nfunction genPath (pnts, smooth, ref) {\n  var maxY = ref.maxY;\n\n  var points = [].concat( pnts );\n  var start = points.shift();\n  var end = points[points.length - 1];\n  var distance = points[0].x - start.x;\n  var bezierX = distance / 2;\n\n  // Create Line Path\n  var linePath = \"M \" + (start.x) + \",\" + (start.y);\n  points.forEach(function (point, index) {\n    if (!smooth) { linePath += \" L\" + (point.x) + \",\" + (point.y); }\n    else {\n      var prev = points[index - 1] || start;\n      linePath += \" C \" + (bezierX + prev.x) + \",\" + (prev.y) + \" \" + (bezierX + prev.x) + \",\" + (point.y) + \" \" + (point.x) + \",\" + (point.y);\n    }\n  });\n\n  // Create Fill Path\n  var fillPath = linePath;\n  if (end.Y !== maxY) { fillPath += \" L\" + (end.x) + \",\" + maxY; }\n  if (start.Y !== maxY) { fillPath += \" L\" + (start.x) + \",\" + maxY; }\n  fillPath += \" Z\";\n\n  return { linePath: linePath, fillPath: fillPath };\n}\n\nvar TrendChartCurve = {\n  name: \"TrendChartCurve\",\n  props: {\n    boundary: {\n      required: true,\n      type: Object\n    },\n    minValue: {\n      required: true,\n      type: Number\n    },\n    maxValue: {\n      required: true,\n      type: Number\n    },\n    maxAmount: {\n      required: true,\n      type: Number\n    },\n    activeLineParams: {\n      type: Object\n    },\n    data: {\n      required: true,\n      type: Array\n    },\n    className: {\n      type: String\n    },\n    smooth: {\n      default: false,\n      type: Boolean\n    },\n    stroke: {\n      default: true,\n      type: Boolean\n    },\n    fill: {\n      default: false,\n      type: Boolean\n    },\n    showPoints: {\n      default: false,\n      type: Boolean\n    }\n  },\n  computed: {\n    points: function points() {\n      return genPoints(\n        this.data,\n        this.boundary,\n        this.maxValue,\n        this.minValue,\n        this.maxAmount\n      );\n    },\n    paths: function paths() {\n      return genPath(this.points, this.smooth, this.boundary);\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = [];\n    // Fill path\n    if (this.fill && this.paths && this.paths.fillPath) {\n      children.push(\n        h(\"path\", {\n          class: \"fill\",\n          attrs: {\n            d: this.paths.fillPath,\n            fill: \"rgba(0,0,0,0.15)\"\n          }\n        })\n      );\n    }\n    // Stroke path\n    if (this.stroke && this.paths && this.paths.linePath) {\n      children.push(\n        h(\"path\", {\n          class: \"stroke\",\n          attrs: {\n            d: this.paths.linePath,\n            fill: \"none\",\n            stroke: \"black\"\n          }\n        })\n      );\n    }\n    // Points\n    if (this.showPoints && this.points) {\n      children.push(\n        h(\n          \"g\",\n          {\n            class: \"points\"\n          },\n          this.points.map(function (point, i) { return h(\"circle\", {\n              class: {\n                point: true,\n                \"is-active\":\n                  this$1.activeLineParams && this$1.activeLineParams.index === i\n              },\n              attrs: {\n                cx: point.x,\n                cy: point.y,\n                r: 2,\n                stroke: \"#000000\",\n                \"stroke-width\": 1\n              }\n            }); }\n          )\n        )\n      );\n    }\n\n    // Render component\n    return h(\n      \"g\",\n      {\n        class: this.className\n      },\n      children\n    );\n  }\n};\n\nvar TrendChart = {\n  name: \"TrendChart\",\n  components: { TrendChartGrid: TrendChartGrid, TrendChartLabels: TrendChartLabels, TrendChartCurve: TrendChartCurve },\n  props: {\n    datasets: {\n      required: true,\n      type: Array\n    },\n    grid: {\n      default: null,\n      type: Object\n    },\n    labels: {\n      default: null,\n      type: Object\n    },\n    max: {\n      type: Number\n    },\n    min: {\n      type: Number\n    },\n    padding: {\n      default: \"5\",\n      type: String,\n      validator: function validator(val) {\n        return validatePadding(val);\n      }\n    },\n    interactive: {\n      default: false,\n      type: Boolean\n    }\n  },\n  data: function data() {\n    return {\n      width: null,\n      height: null,\n      labelsOverflowObject: { top: 0, right: 0, bottom: 0, left: 0 },\n      activeLine: null,\n      activeLineParams: null\n    };\n  },\n  computed: {\n    paddingObject: function paddingObject() {\n      if (!this.padding) { return getPadding(\"0\"); }\n      return getPadding(this.padding);\n    },\n    boundary: function boundary() {\n      var ref = this;\n      var width = ref.width;\n      var height = ref.height;\n      var paddingObject = ref.paddingObject;\n      var labelsOverflowObject = ref.labelsOverflowObject;\n      var boundary = {\n        minX: paddingObject.left + labelsOverflowObject.left,\n        minY: paddingObject.top + labelsOverflowObject.top,\n        maxX: width - paddingObject.right - labelsOverflowObject.right,\n        maxY: height - paddingObject.bottom - labelsOverflowObject.bottom\n      };\n      return boundary;\n    },\n    params: function params() {\n      var maxValue = -Infinity;\n      var minValue = Infinity;\n      var maxAmount = 0;\n      this.datasets.forEach(function (dataset) {\n        var dataArr = dataset.data.map(function (item) { return typeof item === \"number\" ? item : item.value; }\n        );\n\n        var max = Math.max.apply(Math, dataArr);\n        if (max > maxValue) { maxValue = max; }\n\n        var min = Math.min.apply(Math, dataArr);\n        if (min < minValue) { minValue = min; }\n\n        if (dataArr.length > maxAmount) { maxAmount = dataArr.length; }\n      });\n      if (this.max !== undefined && this.max > maxValue) { maxValue = this.max; }\n      if (this.min !== undefined && this.min < minValue) { minValue = this.min; }\n      return { maxValue: maxValue, minValue: minValue, maxAmount: maxAmount };\n    },\n    chartOverlayParams: function chartOverlayParams() {\n      var ref = this;\n      var boundary = ref.boundary;\n      var width = boundary.maxX - boundary.minX;\n      var height = boundary.maxY - boundary.minY;\n      return {\n        x: boundary.minX,\n        y: boundary.minY,\n        width: width > 0 ? width : 0,\n        height: height > 0 ? height : 0,\n        opacity: 0\n      };\n    },\n    chartAxesXCoords: function chartAxesXCoords() {\n      var axes = [];\n      var step =\n        (this.boundary.maxX - this.boundary.minX) / (this.params.maxAmount - 1);\n      for (var i = 0; i < this.params.maxAmount; i++) {\n        axes.push(step * i + this.boundary.minX);\n      }\n      return axes;\n    }\n  },\n  methods: {\n    setSize: function setSize() {\n      var params = this.$refs[\"chart\"].getBoundingClientRect();\n      this.width = params.width;\n      this.height = params.height;\n    },\n    fitLabels: function fitLabels() {\n      var chart = this.$refs[\"chart\"];\n      var chartLabels = this.$refs[\"labels\"];\n      if (\n        chartLabels &&\n        ((chartLabels.xLabels && chartLabels.xLabels.length) ||\n          chartLabels.yLabels > 0)\n      ) {\n        var chartClientRect = chart.getBoundingClientRect();\n        var chartLabelsClientRect = chartLabels.$el.getBoundingClientRect();\n\n        var top =\n          chartClientRect.top -\n          chartLabelsClientRect.top +\n          this.paddingObject.top;\n        var right =\n          chartLabelsClientRect.right -\n          chartClientRect.right +\n          this.paddingObject.right;\n        var bottom =\n          chartLabelsClientRect.bottom -\n          chartClientRect.bottom +\n          this.paddingObject.bottom;\n        var left =\n          this.paddingObject.left -\n          chartLabelsClientRect.left +\n          chartClientRect.left;\n\n        this.labelsOverflowObject = {\n          top: top > 0 ? top : 0,\n          right: right > 0 ? right : 0,\n          bottom: bottom > 0 ? bottom : 0,\n          left: left > 0 ? left : 0\n        };\n      } else {\n        this.labelsOverflowObject = { top: 0, right: 0, bottom: 0, left: 0 };\n      }\n    },\n    init: function init() {\n      var this$1 = this;\n\n      this.setSize();\n      this.$nextTick(function () {\n        this$1.fitLabels();\n      });\n    },\n    getNearestCoordinate: function getNearestCoordinate(val) {\n      return (\n        this.chartAxesXCoords.reduce(\n          function (p, n) { return (Math.abs(p) > Math.abs(n - val) ? n - val : p); },\n          Infinity\n        ) + val\n      );\n    },\n    mouseMove: function mouseMove(e) {\n      var rect = this.$refs.chart.getBoundingClientRect();\n      this.activeLine = this.getNearestCoordinate(e.clientX - rect.left);\n    },\n    mouseOut: function mouseOut() {\n      this.activeLine = null;\n      this.activeLineParams = null;\n    },\n    onWindowResize: function onWindowResize() {\n      this.setSize();\n    }\n  },\n  watch: {\n    activeLine: function activeLine(val) {\n      var this$1 = this;\n\n      var data = [];\n      if (val) {\n        this.activeLineParams = {\n          index: this.chartAxesXCoords.indexOf(this.activeLine)\n        };\n        this.datasets.forEach(function (dataset) {\n          data.push(dataset.data[this$1.activeLineParams.index]);\n        });\n      }\n\n      this.$emit(\n        \"mouseMove\",\n        this.activeLineParams ? Object.assign({}, this.activeLineParams, {data: data}) : null\n      );\n    },\n    labels: {\n      handler: function handler() {\n        var this$1 = this;\n\n        // Reset labels rect overflow\n        this.labelsOverflowObject = { top: 0, right: 0, bottom: 0, left: 0 };\n        // Calculate new labels rect overflow\n        this.$nextTick(function () {\n          this$1.fitLabels();\n        });\n      },\n      deep: true\n    }\n  },\n  mounted: function mounted() {\n    this.init();\n    window.addEventListener(\"resize\", this.onWindowResize);\n  },\n  destroyed: function destroyed() {\n    window.removeEventListener(\"resize\", this.onWindowResize);\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = [];\n\n    // Grid\n    if (this.grid) {\n      children.push(\n        h(TrendChartGrid, {\n          class: \"grid\",\n          attrs: {\n            verticalLines: this.grid.verticalLines,\n            verticalLinesNumber:\n              this.grid.verticalLinesNumber || this.params.maxAmount,\n            horizontalLines: this.grid.horizontalLines,\n            horizontalLinesNumber:\n              this.grid.horizontalLinesNumber ||\n              (this.labels && this.labels.yLabels) ||\n              0,\n            boundary: this.boundary\n          }\n        })\n      );\n    }\n\n    // Chart active line\n    if (this.interactive && this.chartOverlayParams) {\n      children.push(\n        h(\"line\", {\n          class: \"active-line\",\n          ref: \"active-line\",\n          attrs: {\n            x1: this.activeLine || this.boundary.minX,\n            x2: this.activeLine || this.boundary.minX,\n            y1: this.boundary.minY,\n            y2: this.boundary.maxY,\n            stroke: \"black\",\n            visibility: this.activeLine ? \"visible\" : \"hidden\"\n          }\n        })\n      );\n    }\n\n    // Labels\n    if (this.labels) {\n      children.push(\n        h(TrendChartLabels, {\n          class: \"labels\",\n          ref: \"labels\",\n          attrs: Object.assign({}, this.labels,\n            {boundary: this.boundary,\n            minValue: this.params.minValue,\n            maxValue: this.params.maxValue})\n        })\n      );\n    }\n\n    // Curves\n    this.datasets.map(function (dataset) {\n      children.push(\n        h(TrendChartCurve, {\n          class: \"curve\",\n          attrs: Object.assign({}, dataset,\n            {boundary: this$1.boundary,\n            minValue: this$1.params.minValue,\n            maxValue: this$1.params.maxValue,\n            maxAmount: this$1.params.maxAmount,\n            activeLineParams: this$1.activeLineParams})\n        })\n      );\n    });\n\n    // Chart overlay\n    if (this.interactive && this.chartOverlayParams) {\n      children.push(\n        h(\"rect\", {\n          ref: \"interactive-area\",\n          attrs: Object.assign({}, this.chartOverlayParams),\n          on: {\n            mousemove: function (e) { return this$1.mouseMove(e); },\n            mouseout: function () { return this$1.mouseOut(); }\n          }\n        })\n      );\n    }\n\n    // Render component\n    return h(\n      \"svg\",\n      {\n        class: \"vtc\",\n        ref: \"chart\",\n        attrs: {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"100%\",\n          height: \"100%\"\n        }\n      },\n      children\n    );\n  }\n};\n\nTrendChart.install = function(Vue) {\n  Vue.component(TrendChart.name, TrendChart);\n};\n\nif (typeof window !== \"undefined\" && window.Vue) {\n  window.Vue.use(TrendChart);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TrendChart);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRyZW5kLWNoYXJ0L2Rpc3QvdnVlLXRyZW5kLWNoYXJ0LmVzbS5qcz85NzFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0IsRUFBRTtBQUNuRCwwQkFBMEIsdUJBQXVCLEVBQUU7QUFDbkQseUNBQXlDLGNBQWM7QUFDdkQsb0NBQW9DLDZDQUE2QyxFQUFFO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0IsRUFBRTtBQUNuRCwwQkFBMEIsdUJBQXVCLEVBQUU7QUFDbkQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdURBQXVELFFBQVE7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxhQUFhO0FBQ2I7QUFDQSwyQ0FBMkM7QUFDM0MsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHFDQUFxQyw0QkFBNEIsRUFBRTtBQUNuRSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHZhbGlkYXRlUGFkZGluZyAocGFkZGluZykge1xuICB2YXIgYXJyID0gcGFkZGluZ1xuICAgIC5zcGxpdChcIiBcIilcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtICE9PSBcIlwiOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHBhcnNlSW50KGl0ZW0pOyB9KTtcbiAgaWYgKGFyci5sZW5ndGggPCAxIHx8IGFyci5sZW5ndGggPiA0KSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiB0eXBlb2YgaXRlbSA9PSBcIm51bWJlclwiICYmIGl0ZW0gPj0gMDsgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhZGRpbmcgKHBhZGRpbmcpIHtcbiAgdmFyIGFyciA9IHBhZGRpbmdcbiAgICAuc3BsaXQoXCIgXCIpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSAhPT0gXCJcIjsgfSlcbiAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBwYXJzZUludChpdGVtKTsgfSk7XG4gIHN3aXRjaCAoYXJyLmxlbmd0aCkge1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiB7IHRvcDogYXJyWzBdLCByaWdodDogYXJyWzFdLCBib3R0b206IGFyclsyXSwgbGVmdDogYXJyWzNdIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geyB0b3A6IGFyclswXSwgcmlnaHQ6IGFyclsxXSwgYm90dG9tOiBhcnJbMl0sIGxlZnQ6IGFyclsxXSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHsgdG9wOiBhcnJbMF0sIHJpZ2h0OiBhcnJbMV0sIGJvdHRvbTogYXJyWzBdLCBsZWZ0OiBhcnJbMV0gfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0b3A6IGFyclswXSwgcmlnaHQ6IGFyclswXSwgYm90dG9tOiBhcnJbMF0sIGxlZnQ6IGFyclswXSB9O1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxudmFyIFRyZW5kQ2hhcnRHcmlkID0ge1xuICBuYW1lOiBcIlRyZW5kQ2hhcnRHcmlkXCIsXG4gIHByb3BzOiB7XG4gICAgYm91bmRhcnk6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfSxcbiAgICB2ZXJ0aWNhbExpbmVzOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuICAgIHZlcnRpY2FsTGluZXNOdW1iZXI6IHtcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIGhvcml6b250YWxMaW5lczoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICBob3Jpem9udGFsTGluZXNOdW1iZXI6IHtcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRWZXJ0aWNhbExpbmVzUGFyYW1zOiBmdW5jdGlvbiBzZXRWZXJ0aWNhbExpbmVzUGFyYW1zKG4pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gcmVmLmJvdW5kYXJ5O1xuICAgICAgdmFyIHZlcnRpY2FsTGluZXNOdW1iZXIgPSByZWYudmVydGljYWxMaW5lc051bWJlcjtcbiAgICAgIHZhciBzdGVwID1cbiAgICAgICAgdmVydGljYWxMaW5lc051bWJlciA+IDFcbiAgICAgICAgICA/IChib3VuZGFyeS5tYXhYIC0gYm91bmRhcnkubWluWCkgLyAodmVydGljYWxMaW5lc051bWJlciAtIDEpXG4gICAgICAgICAgOiAwO1xuICAgICAgdmFyIHggPSBib3VuZGFyeS5taW5YICsgc3RlcCAqIChuIC0gMSk7XG4gICAgICB2YXIgeTEgPSBib3VuZGFyeS5taW5ZO1xuICAgICAgdmFyIHkyID0gYm91bmRhcnkubWF4WTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4LFxuICAgICAgICB4MjogeCxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsMCwwLDAuMSlcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldEhvcml6b250YWxMaW5lc1BhcmFtczogZnVuY3Rpb24gc2V0SG9yaXpvbnRhbExpbmVzUGFyYW1zKG4pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gcmVmLmJvdW5kYXJ5O1xuICAgICAgdmFyIGhvcml6b250YWxMaW5lc051bWJlciA9IHJlZi5ob3Jpem9udGFsTGluZXNOdW1iZXI7XG4gICAgICB2YXIgc3RlcCA9XG4gICAgICAgIGhvcml6b250YWxMaW5lc051bWJlciA+IDFcbiAgICAgICAgICA/IChib3VuZGFyeS5tYXhZIC0gYm91bmRhcnkubWluWSkgLyAoaG9yaXpvbnRhbExpbmVzTnVtYmVyIC0gMSlcbiAgICAgICAgICA6IDA7XG4gICAgICB2YXIgeSA9IGJvdW5kYXJ5Lm1heFkgLSBzdGVwICogKG4gLSAxKTtcbiAgICAgIHZhciB4MSA9IGJvdW5kYXJ5Lm1pblg7XG4gICAgICB2YXIgeDIgPSBib3VuZGFyeS5tYXhYO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5LFxuICAgICAgICB5MjogeSxcbiAgICAgICAgc3Ryb2tlOiBcInJnYmEoMCwwLDAsMC4xKVwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIGlmICghdGhpcy52ZXJ0aWNhbExpbmVzICYmICF0aGlzLmhvcml6b250YWxMaW5lcykgeyByZXR1cm47IH1cblxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgLy8gVmVydGljYWwgTGluZXNcbiAgICBpZiAodGhpcy52ZXJ0aWNhbExpbmVzICYmIHRoaXMudmVydGljYWxMaW5lc051bWJlciA+IDApIHtcbiAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy52ZXJ0aWNhbExpbmVzTnVtYmVyOyBpKyspIHtcbiAgICAgICAgbGluZXMucHVzaChcbiAgICAgICAgICBoKFwibGluZVwiLCB7XG4gICAgICAgICAgICBjbGFzczogXCJsaW5lXCIsXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZXRWZXJ0aWNhbExpbmVzUGFyYW1zKGkpKVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFxuICAgICAgICAgIFwiZ1wiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzOiBcInZlcnRpY2FsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIEhvcml6b250YWwgTGluZXNcbiAgICBpZiAodGhpcy5ob3Jpem9udGFsTGluZXMgJiYgdGhpcy5ob3Jpem9udGFsTGluZXNOdW1iZXIgPiAwKSB7XG4gICAgICB2YXIgbGluZXMkMSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDw9IHRoaXMuaG9yaXpvbnRhbExpbmVzTnVtYmVyOyBpJDErKykge1xuICAgICAgICBsaW5lcyQxLnB1c2goXG4gICAgICAgICAgaChcImxpbmVcIiwge1xuICAgICAgICAgICAgY2xhc3M6IFwibGluZVwiLFxuICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2V0SG9yaXpvbnRhbExpbmVzUGFyYW1zKGkkMSkpXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIGgoXG4gICAgICAgICAgXCJnXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3M6IFwiaG9yaXpvbnRhbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW5lcyQxXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGNvbXBvbmVudFxuICAgIHJldHVybiBoKFwiZ1wiLCBjaGlsZHJlbik7XG4gIH1cbn07XG5cbnZhciBUcmVuZENoYXJ0TGFiZWxzID0ge1xuICBuYW1lOiBcIlRyZW5kQ2hhcnRMYWJlbHNcIixcbiAgcHJvcHM6IHtcbiAgICBib3VuZGFyeToge1xuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIG1pblZhbHVlOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIG1heFZhbHVlOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIHhMYWJlbHM6IHtcbiAgICAgIHR5cGU6IEFycmF5XG4gICAgfSxcbiAgICB5TGFiZWxzOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIHlMYWJlbHNUZXh0Rm9ybWF0dGVyOiB7XG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9LFxuICAgICAgdHlwZTogRnVuY3Rpb25cbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhMYWJlbEhlaWdodDogbnVsbCxcbiAgICAgIHlMYWJlbEhlaWdodDogbnVsbFxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRYTGFiZWxzUGFyYW1zOiBmdW5jdGlvbiBzZXRYTGFiZWxzUGFyYW1zKG4pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gcmVmLmJvdW5kYXJ5O1xuICAgICAgdmFyIHhMYWJlbHMgPSByZWYueExhYmVscztcbiAgICAgIHZhciBzdGVwID0gKGJvdW5kYXJ5Lm1heFggLSBib3VuZGFyeS5taW5YKSAvICh4TGFiZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIHggPSBib3VuZGFyeS5taW5YICsgc3RlcCAqIG47XG4gICAgICB2YXIgeSA9IGJvdW5kYXJ5Lm1heFk7XG4gICAgICByZXR1cm4geyB0cmFuc2Zvcm06IChcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpXCIpIH07XG4gICAgfSxcbiAgICBzZXRZTGFiZWxzUGFyYW1zOiBmdW5jdGlvbiBzZXRZTGFiZWxzUGFyYW1zKG4pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gcmVmLmJvdW5kYXJ5O1xuICAgICAgdmFyIHlMYWJlbHMgPSByZWYueUxhYmVscztcbiAgICAgIHZhciBzdGVwID0gKGJvdW5kYXJ5Lm1heFkgLSBib3VuZGFyeS5taW5ZKSAvICh5TGFiZWxzIC0gMSk7XG4gICAgICB2YXIgeCA9IGJvdW5kYXJ5Lm1pblg7XG4gICAgICB2YXIgeSA9IGJvdW5kYXJ5Lm1heFkgLSBzdGVwICogbjtcbiAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogKFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBcIilcIikgfTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMueExhYmVscyAmJiB0aGlzLnhMYWJlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnhMYWJlbEhlaWdodCA9IHRoaXMuJHJlZnMueExhYmVsc1xuICAgICAgICAucXVlcnlTZWxlY3RvcihcInRleHRcIilcbiAgICAgICAgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKHRoaXMueUxhYmVscyAmJiB0aGlzLnlMYWJlbHMgPiAwKSB7XG4gICAgICB0aGlzLnlMYWJlbEhlaWdodCA9IHRoaXMuJHJlZnMueUxhYmVsc1xuICAgICAgICAucXVlcnlTZWxlY3RvcihcInRleHRcIilcbiAgICAgICAgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChcbiAgICAgICEodGhpcy54TGFiZWxzICYmIHRoaXMueExhYmVscy5sZW5ndGgpICYmXG4gICAgICAhKHRoaXMueUxhYmVscyAmJiB0aGlzLnlMYWJlbHMgPiAwKVxuICAgIClcbiAgICAgIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIHggbGFiZWxzXG4gICAgaWYgKHRoaXMueExhYmVscyAmJiB0aGlzLnhMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFxuICAgICAgICAgIFwiZ1wiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzOiBcIngtbGFiZWxzXCIsXG4gICAgICAgICAgICByZWY6IFwieExhYmVsc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLnhMYWJlbHMubWFwKGZ1bmN0aW9uIChsYWJlbCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGgoXG4gICAgICAgICAgICAgIFwiZ1wiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcyQxLnNldFhMYWJlbHNQYXJhbXMoaSkpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBoKFxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZHk6IHRoaXMkMS54TGFiZWxIZWlnaHQgKyA1LFxuICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGgoXCJsaW5lXCIsIHsgYXR0cnM6IHsgc3Ryb2tlOiBcInJnYmEoMCwwLDAsMC4xKVwiLCB5MjogNSB9IH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB5IGxhYmVsc1xuICAgIGlmICh0aGlzLnlMYWJlbHMgJiYgdGhpcy55TGFiZWxzID4gMCkge1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnlMYWJlbHM7IGkrKykge1xuICAgICAgICBsYWJlbHMucHVzaChcbiAgICAgICAgICBoKFxuICAgICAgICAgICAgXCJnXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzOiBcImxhYmVsXCIsXG4gICAgICAgICAgICAgIGF0dHJzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNldFlMYWJlbHNQYXJhbXMoaSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBoKFxuICAgICAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGR4OiAtMTAsXG4gICAgICAgICAgICAgICAgICAgIGR5OiB0aGlzLnlMYWJlbEhlaWdodCAvIDQsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJlbmRcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy55TGFiZWxzVGV4dEZvcm1hdHRlcihcbiAgICAgICAgICAgICAgICAgIHRoaXMubWluVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAoKHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlKSAvICh0aGlzLnlMYWJlbHMgLSAxKSkgKiBpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBoKFwibGluZVwiLCB7IGF0dHJzOiB7IHN0cm9rZTogXCJyZ2JhKDAsMCwwLDAuMSlcIiwgeDE6IDAsIHgyOiAtNSB9IH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgaChcbiAgICAgICAgICBcImdcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzczogXCJ5LWxhYmVsc1wiLFxuICAgICAgICAgICAgcmVmOiBcInlMYWJlbHNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGFiZWxzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGNvbXBvbmVudFxuICAgIHJldHVybiBoKFwiZ1wiLCBjaGlsZHJlbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlblBvaW50cyAoYXJyLCByZWYsIG1heCwgbWluLCBtYXhBbW91bnQpIHtcbiAgdmFyIG1pblggPSByZWYubWluWDtcbiAgdmFyIG1pblkgPSByZWYubWluWTtcbiAgdmFyIG1heFggPSByZWYubWF4WDtcbiAgdmFyIG1heFkgPSByZWYubWF4WTtcblxuICBhcnIgPSBhcnIubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAodHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIgPyBpdGVtIDogaXRlbS52YWx1ZSk7IH0pO1xuICB2YXIgbWluVmFsdWUgPSBtaW4gLSAwLjAwMTtcbiAgdmFyIGdyaWRYID0gKG1heFggLSBtaW5YKSAvIChtYXhBbW91bnQgLSAxKTtcbiAgdmFyIGdyaWRZID0gKG1heFkgLSBtaW5ZKSAvIChtYXggKyAwLjAwMSAtIG1pblZhbHVlKTtcblxuICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGluZGV4ICogZ3JpZFggKyBtaW5YLFxuICAgICAgeTpcbiAgICAgICAgbWF4WSAtXG4gICAgICAgICh2YWx1ZSAtIG1pblZhbHVlKSAqIGdyaWRZICtcbiAgICAgICAgKyhpbmRleCA9PT0gbWF4QW1vdW50IC0gMSkgKiAwLjAwMDAxIC1cbiAgICAgICAgKyhpbmRleCA9PT0gMCkgKiAwLjAwMDAxXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlblBhdGggKHBudHMsIHNtb290aCwgcmVmKSB7XG4gIHZhciBtYXhZID0gcmVmLm1heFk7XG5cbiAgdmFyIHBvaW50cyA9IFtdLmNvbmNhdCggcG50cyApO1xuICB2YXIgc3RhcnQgPSBwb2ludHMuc2hpZnQoKTtcbiAgdmFyIGVuZCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIHZhciBkaXN0YW5jZSA9IHBvaW50c1swXS54IC0gc3RhcnQueDtcbiAgdmFyIGJlemllclggPSBkaXN0YW5jZSAvIDI7XG5cbiAgLy8gQ3JlYXRlIExpbmUgUGF0aFxuICB2YXIgbGluZVBhdGggPSBcIk0gXCIgKyAoc3RhcnQueCkgKyBcIixcIiArIChzdGFydC55KTtcbiAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xuICAgIGlmICghc21vb3RoKSB7IGxpbmVQYXRoICs9IFwiIExcIiArIChwb2ludC54KSArIFwiLFwiICsgKHBvaW50LnkpOyB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcHJldiA9IHBvaW50c1tpbmRleCAtIDFdIHx8IHN0YXJ0O1xuICAgICAgbGluZVBhdGggKz0gXCIgQyBcIiArIChiZXppZXJYICsgcHJldi54KSArIFwiLFwiICsgKHByZXYueSkgKyBcIiBcIiArIChiZXppZXJYICsgcHJldi54KSArIFwiLFwiICsgKHBvaW50LnkpICsgXCIgXCIgKyAocG9pbnQueCkgKyBcIixcIiArIChwb2ludC55KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBGaWxsIFBhdGhcbiAgdmFyIGZpbGxQYXRoID0gbGluZVBhdGg7XG4gIGlmIChlbmQuWSAhPT0gbWF4WSkgeyBmaWxsUGF0aCArPSBcIiBMXCIgKyAoZW5kLngpICsgXCIsXCIgKyBtYXhZOyB9XG4gIGlmIChzdGFydC5ZICE9PSBtYXhZKSB7IGZpbGxQYXRoICs9IFwiIExcIiArIChzdGFydC54KSArIFwiLFwiICsgbWF4WTsgfVxuICBmaWxsUGF0aCArPSBcIiBaXCI7XG5cbiAgcmV0dXJuIHsgbGluZVBhdGg6IGxpbmVQYXRoLCBmaWxsUGF0aDogZmlsbFBhdGggfTtcbn1cblxudmFyIFRyZW5kQ2hhcnRDdXJ2ZSA9IHtcbiAgbmFtZTogXCJUcmVuZENoYXJ0Q3VydmVcIixcbiAgcHJvcHM6IHtcbiAgICBib3VuZGFyeToge1xuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIG1pblZhbHVlOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG4gICAgbWF4VmFsdWU6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICBtYXhBbW91bnQ6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICBhY3RpdmVMaW5lUGFyYW1zOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdHlwZTogQXJyYXlcbiAgICB9LFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBzbW9vdGg6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgc3Ryb2tlOiB7XG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgZmlsbDoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICBzaG93UG9pbnRzOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgcG9pbnRzOiBmdW5jdGlvbiBwb2ludHMoKSB7XG4gICAgICByZXR1cm4gZ2VuUG9pbnRzKFxuICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgIHRoaXMuYm91bmRhcnksXG4gICAgICAgIHRoaXMubWF4VmFsdWUsXG4gICAgICAgIHRoaXMubWluVmFsdWUsXG4gICAgICAgIHRoaXMubWF4QW1vdW50XG4gICAgICApO1xuICAgIH0sXG4gICAgcGF0aHM6IGZ1bmN0aW9uIHBhdGhzKCkge1xuICAgICAgcmV0dXJuIGdlblBhdGgodGhpcy5wb2ludHMsIHRoaXMuc21vb3RoLCB0aGlzLmJvdW5kYXJ5KTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIC8vIEZpbGwgcGF0aFxuICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5wYXRocyAmJiB0aGlzLnBhdGhzLmZpbGxQYXRoKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFwicGF0aFwiLCB7XG4gICAgICAgICAgY2xhc3M6IFwiZmlsbFwiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkOiB0aGlzLnBhdGhzLmZpbGxQYXRoLFxuICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDAsMCwwLDAuMTUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBTdHJva2UgcGF0aFxuICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnBhdGhzICYmIHRoaXMucGF0aHMubGluZVBhdGgpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIGgoXCJwYXRoXCIsIHtcbiAgICAgICAgICBjbGFzczogXCJzdHJva2VcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZDogdGhpcy5wYXRocy5saW5lUGF0aCxcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcImJsYWNrXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBQb2ludHNcbiAgICBpZiAodGhpcy5zaG93UG9pbnRzICYmIHRoaXMucG9pbnRzKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFxuICAgICAgICAgIFwiZ1wiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzOiBcInBvaW50c1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7IHJldHVybiBoKFwiY2lyY2xlXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBwb2ludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImlzLWFjdGl2ZVwiOlxuICAgICAgICAgICAgICAgICAgdGhpcyQxLmFjdGl2ZUxpbmVQYXJhbXMgJiYgdGhpcyQxLmFjdGl2ZUxpbmVQYXJhbXMuaW5kZXggPT09IGlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBjeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICBjeTogcG9pbnQueSxcbiAgICAgICAgICAgICAgICByOiAyLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgfVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgY29tcG9uZW50XG4gICAgcmV0dXJuIGgoXG4gICAgICBcImdcIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3NOYW1lXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG59O1xuXG52YXIgVHJlbmRDaGFydCA9IHtcbiAgbmFtZTogXCJUcmVuZENoYXJ0XCIsXG4gIGNvbXBvbmVudHM6IHsgVHJlbmRDaGFydEdyaWQ6IFRyZW5kQ2hhcnRHcmlkLCBUcmVuZENoYXJ0TGFiZWxzOiBUcmVuZENoYXJ0TGFiZWxzLCBUcmVuZENoYXJ0Q3VydmU6IFRyZW5kQ2hhcnRDdXJ2ZSB9LFxuICBwcm9wczoge1xuICAgIGRhdGFzZXRzOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHR5cGU6IEFycmF5XG4gICAgfSxcbiAgICBncmlkOiB7XG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICBtaW46IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgZGVmYXVsdDogXCI1XCIsXG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUGFkZGluZyh2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZXJhY3RpdmU6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBsYWJlbHNPdmVyZmxvd09iamVjdDogeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfSxcbiAgICAgIGFjdGl2ZUxpbmU6IG51bGwsXG4gICAgICBhY3RpdmVMaW5lUGFyYW1zOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBwYWRkaW5nT2JqZWN0OiBmdW5jdGlvbiBwYWRkaW5nT2JqZWN0KCkge1xuICAgICAgaWYgKCF0aGlzLnBhZGRpbmcpIHsgcmV0dXJuIGdldFBhZGRpbmcoXCIwXCIpOyB9XG4gICAgICByZXR1cm4gZ2V0UGFkZGluZyh0aGlzLnBhZGRpbmcpO1xuICAgIH0sXG4gICAgYm91bmRhcnk6IGZ1bmN0aW9uIGJvdW5kYXJ5KCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICAgIHZhciBwYWRkaW5nT2JqZWN0ID0gcmVmLnBhZGRpbmdPYmplY3Q7XG4gICAgICB2YXIgbGFiZWxzT3ZlcmZsb3dPYmplY3QgPSByZWYubGFiZWxzT3ZlcmZsb3dPYmplY3Q7XG4gICAgICB2YXIgYm91bmRhcnkgPSB7XG4gICAgICAgIG1pblg6IHBhZGRpbmdPYmplY3QubGVmdCArIGxhYmVsc092ZXJmbG93T2JqZWN0LmxlZnQsXG4gICAgICAgIG1pblk6IHBhZGRpbmdPYmplY3QudG9wICsgbGFiZWxzT3ZlcmZsb3dPYmplY3QudG9wLFxuICAgICAgICBtYXhYOiB3aWR0aCAtIHBhZGRpbmdPYmplY3QucmlnaHQgLSBsYWJlbHNPdmVyZmxvd09iamVjdC5yaWdodCxcbiAgICAgICAgbWF4WTogaGVpZ2h0IC0gcGFkZGluZ09iamVjdC5ib3R0b20gLSBsYWJlbHNPdmVyZmxvd09iamVjdC5ib3R0b21cbiAgICAgIH07XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSxcbiAgICBwYXJhbXM6IGZ1bmN0aW9uIHBhcmFtcygpIHtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IEluZmluaXR5O1xuICAgICAgdmFyIG1heEFtb3VudCA9IDA7XG4gICAgICB0aGlzLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgICAgdmFyIGRhdGFBcnIgPSBkYXRhc2V0LmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIiA/IGl0ZW0gOiBpdGVtLnZhbHVlOyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRhdGFBcnIpO1xuICAgICAgICBpZiAobWF4ID4gbWF4VmFsdWUpIHsgbWF4VmFsdWUgPSBtYXg7IH1cblxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YUFycik7XG4gICAgICAgIGlmIChtaW4gPCBtaW5WYWx1ZSkgeyBtaW5WYWx1ZSA9IG1pbjsgfVxuXG4gICAgICAgIGlmIChkYXRhQXJyLmxlbmd0aCA+IG1heEFtb3VudCkgeyBtYXhBbW91bnQgPSBkYXRhQXJyLmxlbmd0aDsgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1heCA+IG1heFZhbHVlKSB7IG1heFZhbHVlID0gdGhpcy5tYXg7IH1cbiAgICAgIGlmICh0aGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMubWluIDwgbWluVmFsdWUpIHsgbWluVmFsdWUgPSB0aGlzLm1pbjsgfVxuICAgICAgcmV0dXJuIHsgbWF4VmFsdWU6IG1heFZhbHVlLCBtaW5WYWx1ZTogbWluVmFsdWUsIG1heEFtb3VudDogbWF4QW1vdW50IH07XG4gICAgfSxcbiAgICBjaGFydE92ZXJsYXlQYXJhbXM6IGZ1bmN0aW9uIGNoYXJ0T3ZlcmxheVBhcmFtcygpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gcmVmLmJvdW5kYXJ5O1xuICAgICAgdmFyIHdpZHRoID0gYm91bmRhcnkubWF4WCAtIGJvdW5kYXJ5Lm1pblg7XG4gICAgICB2YXIgaGVpZ2h0ID0gYm91bmRhcnkubWF4WSAtIGJvdW5kYXJ5Lm1pblk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBib3VuZGFyeS5taW5YLFxuICAgICAgICB5OiBib3VuZGFyeS5taW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGggPiAwID8gd2lkdGggOiAwLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCA+IDAgPyBoZWlnaHQgOiAwLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2hhcnRBeGVzWENvb3JkczogZnVuY3Rpb24gY2hhcnRBeGVzWENvb3JkcygpIHtcbiAgICAgIHZhciBheGVzID0gW107XG4gICAgICB2YXIgc3RlcCA9XG4gICAgICAgICh0aGlzLmJvdW5kYXJ5Lm1heFggLSB0aGlzLmJvdW5kYXJ5Lm1pblgpIC8gKHRoaXMucGFyYW1zLm1heEFtb3VudCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5tYXhBbW91bnQ7IGkrKykge1xuICAgICAgICBheGVzLnB1c2goc3RlcCAqIGkgKyB0aGlzLmJvdW5kYXJ5Lm1pblgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF4ZXM7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLiRyZWZzW1wiY2hhcnRcIl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgZml0TGFiZWxzOiBmdW5jdGlvbiBmaXRMYWJlbHMoKSB7XG4gICAgICB2YXIgY2hhcnQgPSB0aGlzLiRyZWZzW1wiY2hhcnRcIl07XG4gICAgICB2YXIgY2hhcnRMYWJlbHMgPSB0aGlzLiRyZWZzW1wibGFiZWxzXCJdO1xuICAgICAgaWYgKFxuICAgICAgICBjaGFydExhYmVscyAmJlxuICAgICAgICAoKGNoYXJ0TGFiZWxzLnhMYWJlbHMgJiYgY2hhcnRMYWJlbHMueExhYmVscy5sZW5ndGgpIHx8XG4gICAgICAgICAgY2hhcnRMYWJlbHMueUxhYmVscyA+IDApXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNoYXJ0Q2xpZW50UmVjdCA9IGNoYXJ0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY2hhcnRMYWJlbHNDbGllbnRSZWN0ID0gY2hhcnRMYWJlbHMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciB0b3AgPVxuICAgICAgICAgIGNoYXJ0Q2xpZW50UmVjdC50b3AgLVxuICAgICAgICAgIGNoYXJ0TGFiZWxzQ2xpZW50UmVjdC50b3AgK1xuICAgICAgICAgIHRoaXMucGFkZGluZ09iamVjdC50b3A7XG4gICAgICAgIHZhciByaWdodCA9XG4gICAgICAgICAgY2hhcnRMYWJlbHNDbGllbnRSZWN0LnJpZ2h0IC1cbiAgICAgICAgICBjaGFydENsaWVudFJlY3QucmlnaHQgK1xuICAgICAgICAgIHRoaXMucGFkZGluZ09iamVjdC5yaWdodDtcbiAgICAgICAgdmFyIGJvdHRvbSA9XG4gICAgICAgICAgY2hhcnRMYWJlbHNDbGllbnRSZWN0LmJvdHRvbSAtXG4gICAgICAgICAgY2hhcnRDbGllbnRSZWN0LmJvdHRvbSArXG4gICAgICAgICAgdGhpcy5wYWRkaW5nT2JqZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGxlZnQgPVxuICAgICAgICAgIHRoaXMucGFkZGluZ09iamVjdC5sZWZ0IC1cbiAgICAgICAgICBjaGFydExhYmVsc0NsaWVudFJlY3QubGVmdCArXG4gICAgICAgICAgY2hhcnRDbGllbnRSZWN0LmxlZnQ7XG5cbiAgICAgICAgdGhpcy5sYWJlbHNPdmVyZmxvd09iamVjdCA9IHtcbiAgICAgICAgICB0b3A6IHRvcCA+IDAgPyB0b3AgOiAwLFxuICAgICAgICAgIHJpZ2h0OiByaWdodCA+IDAgPyByaWdodCA6IDAsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20gPiAwID8gYm90dG9tIDogMCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0ID4gMCA/IGxlZnQgOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhYmVsc092ZXJmbG93T2JqZWN0ID0geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5zZXRTaXplKCk7XG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMkMS5maXRMYWJlbHMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0TmVhcmVzdENvb3JkaW5hdGU6IGZ1bmN0aW9uIGdldE5lYXJlc3RDb29yZGluYXRlKHZhbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5jaGFydEF4ZXNYQ29vcmRzLnJlZHVjZShcbiAgICAgICAgICBmdW5jdGlvbiAocCwgbikgeyByZXR1cm4gKE1hdGguYWJzKHApID4gTWF0aC5hYnMobiAtIHZhbCkgPyBuIC0gdmFsIDogcCk7IH0sXG4gICAgICAgICAgSW5maW5pdHlcbiAgICAgICAgKSArIHZhbFxuICAgICAgKTtcbiAgICB9LFxuICAgIG1vdXNlTW92ZTogZnVuY3Rpb24gbW91c2VNb3ZlKGUpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy4kcmVmcy5jaGFydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuYWN0aXZlTGluZSA9IHRoaXMuZ2V0TmVhcmVzdENvb3JkaW5hdGUoZS5jbGllbnRYIC0gcmVjdC5sZWZ0KTtcbiAgICB9LFxuICAgIG1vdXNlT3V0OiBmdW5jdGlvbiBtb3VzZU91dCgpIHtcbiAgICAgIHRoaXMuYWN0aXZlTGluZSA9IG51bGw7XG4gICAgICB0aGlzLmFjdGl2ZUxpbmVQYXJhbXMgPSBudWxsO1xuICAgIH0sXG4gICAgb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICAgICAgdGhpcy5zZXRTaXplKCk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGFjdGl2ZUxpbmU6IGZ1bmN0aW9uIGFjdGl2ZUxpbmUodmFsKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVMaW5lUGFyYW1zID0ge1xuICAgICAgICAgIGluZGV4OiB0aGlzLmNoYXJ0QXhlc1hDb29yZHMuaW5kZXhPZih0aGlzLmFjdGl2ZUxpbmUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgICAgIGRhdGEucHVzaChkYXRhc2V0LmRhdGFbdGhpcyQxLmFjdGl2ZUxpbmVQYXJhbXMuaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVtaXQoXG4gICAgICAgIFwibW91c2VNb3ZlXCIsXG4gICAgICAgIHRoaXMuYWN0aXZlTGluZVBhcmFtcyA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYWN0aXZlTGluZVBhcmFtcywge2RhdGE6IGRhdGF9KSA6IG51bGxcbiAgICAgICk7XG4gICAgfSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlc2V0IGxhYmVscyByZWN0IG92ZXJmbG93XG4gICAgICAgIHRoaXMubGFiZWxzT3ZlcmZsb3dPYmplY3QgPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGxhYmVscyByZWN0IG92ZXJmbG93XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuZml0TGFiZWxzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbldpbmRvd1Jlc2l6ZSk7XG4gIH0sXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25XaW5kb3dSZXNpemUpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIEdyaWRcbiAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFRyZW5kQ2hhcnRHcmlkLCB7XG4gICAgICAgICAgY2xhc3M6IFwiZ3JpZFwiLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB2ZXJ0aWNhbExpbmVzOiB0aGlzLmdyaWQudmVydGljYWxMaW5lcyxcbiAgICAgICAgICAgIHZlcnRpY2FsTGluZXNOdW1iZXI6XG4gICAgICAgICAgICAgIHRoaXMuZ3JpZC52ZXJ0aWNhbExpbmVzTnVtYmVyIHx8IHRoaXMucGFyYW1zLm1heEFtb3VudCxcbiAgICAgICAgICAgIGhvcml6b250YWxMaW5lczogdGhpcy5ncmlkLmhvcml6b250YWxMaW5lcyxcbiAgICAgICAgICAgIGhvcml6b250YWxMaW5lc051bWJlcjpcbiAgICAgICAgICAgICAgdGhpcy5ncmlkLmhvcml6b250YWxMaW5lc051bWJlciB8fFxuICAgICAgICAgICAgICAodGhpcy5sYWJlbHMgJiYgdGhpcy5sYWJlbHMueUxhYmVscykgfHxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBhY3RpdmUgbGluZVxuICAgIGlmICh0aGlzLmludGVyYWN0aXZlICYmIHRoaXMuY2hhcnRPdmVybGF5UGFyYW1zKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFwibGluZVwiLCB7XG4gICAgICAgICAgY2xhc3M6IFwiYWN0aXZlLWxpbmVcIixcbiAgICAgICAgICByZWY6IFwiYWN0aXZlLWxpbmVcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDE6IHRoaXMuYWN0aXZlTGluZSB8fCB0aGlzLmJvdW5kYXJ5Lm1pblgsXG4gICAgICAgICAgICB4MjogdGhpcy5hY3RpdmVMaW5lIHx8IHRoaXMuYm91bmRhcnkubWluWCxcbiAgICAgICAgICAgIHkxOiB0aGlzLmJvdW5kYXJ5Lm1pblksXG4gICAgICAgICAgICB5MjogdGhpcy5ib3VuZGFyeS5tYXhZLFxuICAgICAgICAgICAgc3Ryb2tlOiBcImJsYWNrXCIsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLmFjdGl2ZUxpbmUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIExhYmVsc1xuICAgIGlmICh0aGlzLmxhYmVscykge1xuICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgaChUcmVuZENoYXJ0TGFiZWxzLCB7XG4gICAgICAgICAgY2xhc3M6IFwibGFiZWxzXCIsXG4gICAgICAgICAgcmVmOiBcImxhYmVsc1wiLFxuICAgICAgICAgIGF0dHJzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxhYmVscyxcbiAgICAgICAgICAgIHtib3VuZGFyeTogdGhpcy5ib3VuZGFyeSxcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzLnBhcmFtcy5taW5WYWx1ZSxcbiAgICAgICAgICAgIG1heFZhbHVlOiB0aGlzLnBhcmFtcy5tYXhWYWx1ZX0pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEN1cnZlc1xuICAgIHRoaXMuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICBoKFRyZW5kQ2hhcnRDdXJ2ZSwge1xuICAgICAgICAgIGNsYXNzOiBcImN1cnZlXCIsXG4gICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe30sIGRhdGFzZXQsXG4gICAgICAgICAgICB7Ym91bmRhcnk6IHRoaXMkMS5ib3VuZGFyeSxcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzJDEucGFyYW1zLm1pblZhbHVlLFxuICAgICAgICAgICAgbWF4VmFsdWU6IHRoaXMkMS5wYXJhbXMubWF4VmFsdWUsXG4gICAgICAgICAgICBtYXhBbW91bnQ6IHRoaXMkMS5wYXJhbXMubWF4QW1vdW50LFxuICAgICAgICAgICAgYWN0aXZlTGluZVBhcmFtczogdGhpcyQxLmFjdGl2ZUxpbmVQYXJhbXN9KVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIENoYXJ0IG92ZXJsYXlcbiAgICBpZiAodGhpcy5pbnRlcmFjdGl2ZSAmJiB0aGlzLmNoYXJ0T3ZlcmxheVBhcmFtcykge1xuICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgaChcInJlY3RcIiwge1xuICAgICAgICAgIHJlZjogXCJpbnRlcmFjdGl2ZS1hcmVhXCIsXG4gICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2hhcnRPdmVybGF5UGFyYW1zKSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcyQxLm1vdXNlTW92ZShlKTsgfSxcbiAgICAgICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEubW91c2VPdXQoKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGNvbXBvbmVudFxuICAgIHJldHVybiBoKFxuICAgICAgXCJzdmdcIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3M6IFwidnRjXCIsXG4gICAgICAgIHJlZjogXCJjaGFydFwiLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgIGhlaWdodDogXCIxMDAlXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxufTtcblxuVHJlbmRDaGFydC5pbnN0YWxsID0gZnVuY3Rpb24oVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQoVHJlbmRDaGFydC5uYW1lLCBUcmVuZENoYXJ0KTtcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVHJlbmRDaGFydCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyZW5kQ2hhcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtdHJlbmQtY2hhcnQvZGlzdC92dWUtdHJlbmQtY2hhcnQuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///273\n");

/***/ }),

/***/ 99:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(124);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_store__ = __webpack_require__(126);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_router__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vee_validate__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_js__ = __webpack_require__(241);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_notification__ = __webpack_require__(242);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_notification___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_vue_notification__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_LeftNaviBar_vue__ = __webpack_require__(243);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_TopHeader_vue__ = __webpack_require__(246);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vuejs_dialog__ = __webpack_require__(251);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vuejs_dialog___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_vuejs_dialog__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vuejs_dialog_dist_vuejs_dialog_min_css__ = __webpack_require__(252);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vuejs_dialog_dist_vuejs_dialog_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_vuejs_dialog_dist_vuejs_dialog_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_products_ProductTable_vue__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__components_purchaseorders_PurchaseOrders_vue__ = __webpack_require__(134);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_passport_AuthorizedClients_vue__ = __webpack_require__(253);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__components_passport_Clients_vue__ = __webpack_require__(256);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__components_passport_PersonalAccessTokens_vue__ = __webpack_require__(259);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_vue_trend_chart__ = __webpack_require__(273);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_v_tooltip__ = __webpack_require__(262);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_jquery__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__router_js__ = __webpack_require__(31);\n\n/**\n * First we will load all of this project's JavaScript dependencies which\n * includes Vue and other libraries. It is a great starting point when\n * building robust, powerful web applications using Vue and Laravel.\n */\n\n__webpack_require__(100);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_16_vue_trend_chart__[\"a\" /* default */]);\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_3_vue_router__[\"a\" /* default */]);\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_4_vee_validate__[\"b\" /* default */]);\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_6_vue_notification___default.a);\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_9_vuejs_dialog___default.a);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_17_v_tooltip__[\"a\" /* default */]);\n\n\nconst $ = __WEBPACK_IMPORTED_MODULE_18_jquery___default.a;\nwindow.$ = $;\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].component('example-component', __webpack_require__(265));\n\nvar vm = new __WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"]({\n  el: '#root',\n  router: __WEBPACK_IMPORTED_MODULE_19__router_js__[\"a\" /* router */], store: __WEBPACK_IMPORTED_MODULE_2__components_store__[\"a\" /* default */],\n  data: {\n    msg: \"Hello World\"\n  },\n  components: {\n    app: __WEBPACK_IMPORTED_MODULE_1__App_vue__[\"a\" /* default */],\n    product_table: __WEBPACK_IMPORTED_MODULE_11__components_products_ProductTable_vue__[\"a\" /* default */],\n    purchase_orders: __WEBPACK_IMPORTED_MODULE_12__components_purchaseorders_PurchaseOrders_vue__[\"a\" /* default */],\n    left_navi_bar: __WEBPACK_IMPORTED_MODULE_7__components_LeftNaviBar_vue__[\"a\" /* default */],\n    app_header: __WEBPACK_IMPORTED_MODULE_8__components_TopHeader_vue__[\"a\" /* default */],\n    passport_authorized_clients: __WEBPACK_IMPORTED_MODULE_13__components_passport_AuthorizedClients_vue__[\"a\" /* default */],\n    passport_clients: __WEBPACK_IMPORTED_MODULE_14__components_passport_Clients_vue__[\"a\" /* default */],\n    passport_personal_access_tokens: __WEBPACK_IMPORTED_MODULE_15__components_passport_PersonalAccessTokens_vue__[\"a\" /* default */]\n\n  },\n  mounted() {}\n\n});\n\nglobal.vm = vm;\n\nwindow.Vue = __WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"]);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FwcC5qcz9iMTVmIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJWdWUiLCJ1c2UiLCIkIiwid2luZG93IiwiY29tcG9uZW50Iiwidm0iLCJlbCIsInJvdXRlciIsImRhdGEiLCJtc2ciLCJjb21wb25lbnRzIiwiYXBwIiwicHJvZHVjdF90YWJsZSIsInB1cmNoYXNlX29yZGVycyIsImxlZnRfbmF2aV9iYXIiLCJhcHBfaGVhZGVyIiwicGFzc3BvcnRfYXV0aG9yaXplZF9jbGllbnRzIiwicGFzc3BvcnRfY2xpZW50cyIsInBhc3Nwb3J0X3BlcnNvbmFsX2FjY2Vzc190b2tlbnMiLCJQZXJzb25hbEFjY2Vzc1Rva2VucyIsIm1vdW50ZWQiLCJnbG9iYWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7Ozs7OztBQU1BLG1CQUFBQSxDQUFRLEdBQVI7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQUFDLENBQUlDLEdBQUosQ0FBUSxpRUFBUjs7QUFHQSw0Q0FBQUQsQ0FBSUMsR0FBSixDQUFRLDJEQUFSO0FBQ0EsNENBQUFELENBQUlDLEdBQUosQ0FBUSw2REFBUjtBQUNBLDRDQUFBRCxDQUFJQyxHQUFKLENBQVEsd0RBQVI7QUFDQSw0Q0FBQUQsQ0FBSUMsR0FBSixDQUFRLG9EQUFSOztBQUVBOztBQUVBLDRDQUFBRCxDQUFJQyxHQUFKLENBQVEsMkRBQVI7O0FBUUE7QUFDQSxNQUFNQyxJQUFJLCtDQUFWO0FBQ0FDLE9BQU9ELENBQVAsR0FBV0EsQ0FBWDs7QUFLQTs7QUFHQSw0Q0FBQUYsQ0FBSUksU0FBSixDQUFjLG1CQUFkLEVBQW1DLG1CQUFBTCxDQUFRLEdBQVIsQ0FBbkM7O0FBRUEsSUFBSU0sS0FBSyxJQUFJLDRDQUFKLENBQVE7QUFDYkMsTUFBSSxPQURTO0FBRWJDLEVBQUEsbUVBRmEsRUFFTix5RUFGTTtBQUdiQyxRQUFNO0FBQ0ZDLFNBQUs7QUFESCxHQUhPO0FBTWJDLGNBQVc7QUFDVEMsU0FBSyx5REFESTtBQUVUQyxtQkFBZSx1RkFGTjtBQUdUQyxxQkFBa0IsK0ZBSFQ7QUFJVEMsbUJBQWUsNEVBSk47QUFLVEMsZ0JBQVcsMEVBTEY7QUFNVEMsaUNBQTRCLDRGQU5uQjtBQU9UQyxzQkFBaUIsa0ZBUFI7QUFRVEMscUNBQWdDLCtGQUFBQzs7QUFSdkIsR0FORTtBQWtCYkMsWUFBUyxDQUVSOztBQXBCWSxDQUFSLENBQVQ7O0FBd0JBQyxPQUFPaEIsRUFBUCxHQUFZQSxFQUFaOztBQUVBRixPQUFPSCxHQUFQLEdBQWEsNENBQWI7O0FBRUEsK0RBQWUsNENBQWYsRSIsImZpbGUiOiI5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBGaXJzdCB3ZSB3aWxsIGxvYWQgYWxsIG9mIHRoaXMgcHJvamVjdCdzIEphdmFTY3JpcHQgZGVwZW5kZW5jaWVzIHdoaWNoXG4gKiBpbmNsdWRlcyBWdWUgYW5kIG90aGVyIGxpYnJhcmllcy4gSXQgaXMgYSBncmVhdCBzdGFydGluZyBwb2ludCB3aGVuXG4gKiBidWlsZGluZyByb2J1c3QsIHBvd2VyZnVsIHdlYiBhcHBsaWNhdGlvbnMgdXNpbmcgVnVlIGFuZCBMYXJhdmVsLlxuICovXG5cbnJlcXVpcmUoJy4vYm9vdHN0cmFwJyk7XG5cblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLnZ1ZSdcbmltcG9ydCBzdG9yZSBmcm9tICcuL2NvbXBvbmVudHMvc3RvcmUnXG5pbXBvcnQgVnVlUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInXG5pbXBvcnQgVmVlVmFsaWRhdGUgZnJvbSAndmVlLXZhbGlkYXRlJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcuanMnO1xuaW1wb3J0IE5vdGlmaWNhdGlvbnMgZnJvbSAndnVlLW5vdGlmaWNhdGlvbidcblxuaW1wb3J0IExlZnROYXZpQmFyIGZyb20gJy4vY29tcG9uZW50cy9MZWZ0TmF2aUJhci52dWUnXG5pbXBvcnQgVG9wSGVhZGVyIGZyb20gJy4vY29tcG9uZW50cy9Ub3BIZWFkZXIudnVlJ1xuXG5cbmltcG9ydCBWdWVqc0RpYWxvZyBmcm9tIFwidnVlanMtZGlhbG9nXCJcblxuaW1wb3J0ICd2dWVqcy1kaWFsb2cvZGlzdC92dWVqcy1kaWFsb2cubWluLmNzcyc7XG5pbXBvcnQgUHJvZHVjdFRhYmxlIGZyb20gJy4vY29tcG9uZW50cy9wcm9kdWN0cy9Qcm9kdWN0VGFibGUudnVlJ1xuaW1wb3J0IFB1cmNoYXNlT3JkZXJzIGZyb20gJy4vY29tcG9uZW50cy9wdXJjaGFzZW9yZGVycy9QdXJjaGFzZU9yZGVycy52dWUnXG5cblxuaW1wb3J0IEF1dGhvcml6ZWRDbGllbnRzIGZyb20gJy4vY29tcG9uZW50cy9wYXNzcG9ydC9BdXRob3JpemVkQ2xpZW50cy52dWUnXG5pbXBvcnQgQ2xpZW50cyBmcm9tICcuL2NvbXBvbmVudHMvcGFzc3BvcnQvQ2xpZW50cy52dWUnXG5pbXBvcnQgUGVyc29uYWxBY2Nlc3NUb2tlbnMgZnJvbSAnLi9jb21wb25lbnRzL3Bhc3Nwb3J0L1BlcnNvbmFsQWNjZXNzVG9rZW5zLnZ1ZSdcbmltcG9ydCBUcmVuZENoYXJ0IGZyb20gXCJ2dWUtdHJlbmQtY2hhcnRcIjtcblxuVnVlLnVzZShUcmVuZENoYXJ0KTtcblxuXG5WdWUudXNlKFZ1ZVJvdXRlcilcblZ1ZS51c2UoVmVlVmFsaWRhdGUpXG5WdWUudXNlKE5vdGlmaWNhdGlvbnMpXG5WdWUudXNlKFZ1ZWpzRGlhbG9nKVxuXG5pbXBvcnQgVlRvb2x0aXAgZnJvbSAndi10b29sdGlwJ1xuXG5WdWUudXNlKFZUb29sdGlwKVxuXG5cblxuXG5cblxuXG5pbXBvcnQgalF1ZXJ5IGZyb20gXCJqcXVlcnlcIlxuY29uc3QgJCA9IGpRdWVyeVxud2luZG93LiQgPSAkO1xuXG5cblxuXG5pbXBvcnQge3JvdXRlcn0gZnJvbSAnLi9yb3V0ZXIuanMnXG5cblxuVnVlLmNvbXBvbmVudCgnZXhhbXBsZS1jb21wb25lbnQnLCByZXF1aXJlKCcuL2NvbXBvbmVudHMvRXhhbXBsZUNvbXBvbmVudC52dWUnKSk7XG5cbnZhciB2bSA9IG5ldyBWdWUoe1xuICAgIGVsOiAnI3Jvb3QnLFxuICAgIHJvdXRlcixzdG9yZSxcbiAgICBkYXRhOiB7XG4gICAgICAgIG1zZzogXCJIZWxsbyBXb3JsZFwiXG4gICAgfSxcbiAgICBjb21wb25lbnRzOntcbiAgICAgXHRhcHA6IEFwcCxcbiAgICAgXHRwcm9kdWN0X3RhYmxlOiBQcm9kdWN0VGFibGUsXG4gICAgICBwdXJjaGFzZV9vcmRlcnMgOiBQdXJjaGFzZU9yZGVycyxcbiAgICAgIGxlZnRfbmF2aV9iYXI6IExlZnROYXZpQmFyLFxuICAgICAgYXBwX2hlYWRlcjpUb3BIZWFkZXIsXG4gICAgICBwYXNzcG9ydF9hdXRob3JpemVkX2NsaWVudHM6QXV0aG9yaXplZENsaWVudHMsXG4gICAgICBwYXNzcG9ydF9jbGllbnRzOkNsaWVudHMsXG4gICAgICBwYXNzcG9ydF9wZXJzb25hbF9hY2Nlc3NfdG9rZW5zOlBlcnNvbmFsQWNjZXNzVG9rZW5zXG5cblxuICAgIH0sXG4gICAgbW91bnRlZCgpe1xuICAgICAgXG4gICAgfVxuICAgIFxufSk7XG5cbmdsb2JhbC52bSA9IHZtO1xuXG53aW5kb3cuVnVlID0gVnVlO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9hcHAuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99\n");

/***/ })

})